def calculate(N, M, weights, values):
    # Матрица dp размером (M+1)x(N+1) для хранения стоимости
    dp = [([0] * (M + 1)) for _ in range(N + 1)]

    # Перебор предметов
    for i in range(1, N + 1):
        for w in range(1, M + 1):
            if weights[i - 1] <= w:
                # Текущий предмет помещается в рюкзак
                # сохраняем максимум из предыдущего и нового значений
                dp[i][w] = max(
                    # Не берем текущий предмет, стоимость будет равна
                    # предыдущей стоимости такой же вместимости
                    dp[i - 1][w],
                    # Берем текущий предмет и добавляем его стоимость
                    # к текущей вместимости минус вес текущего предмета
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                )
            else:
                # Текущий предмет не помещается в рюкзак
                # копируем значение из предыдущей строки такой же вместимости
                dp[i][w] = dp[i - 1][w]

    # Максимальная стоимость рюкзака будет в ячейке dp[N][M]
    return dp[N][M]


def test():
    print(calculate(3, 100, [80, 40, 50], [30, 10, 15]))
    print(calculate(3, 100, [80, 40, 50], [30, 16, 15]))
    print(calculate(4, 100, [80, 40, 50, 20], [30, 30, 15, 10]))
    print(calculate(4, 100, [80, 40, 50, 20], [30, 20, 15, 10]))


# Функция для быстрого тестирования алгоритма
# test()

# Чтение входных данных
N, M = [int(x) for x in input().split()]
weights = [int(x) for x in input().split()]
values = [int(x) for x in input().split()]

# Вызов функции и вывод результата
print(calculate(N, M, weights, values))
